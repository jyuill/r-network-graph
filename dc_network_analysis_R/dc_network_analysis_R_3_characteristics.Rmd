---
title: "Network Analytics in R: Chapter 3"
author: "`r Sys.getenv('USER')`"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_depth: 4
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message=FALSE,
                      warning=FALSE,
                      fig.height=6,
                      fig.width=8)

library(igraph)
library(igraphdata) ## data sets for working with igraph

library(tidyverse)
library(lubridate)
library(here)
library(PerformanceAnalytics)
library(plotly)
library(scales)
library(gridExtra)
library(DT)

```

## Chapter 3: Characterizing of Network Structures

Notes from DataCamp course ['Network Analysis in R'](https://learn.datacamp.com/courses/network-analysis-in-r) **Chapter 3: Characterizing Network Structures.**

### Key Concepts

* Convert data frame to graph
* Centrality, Density, Ave. Path Length (distance)
* Random graph generation for context/comparison
* Substructure: transitivity, clique

### Get / Explore Data

Datacamp exercises use Forrest Gump movie character network data - pairs of actors who appear in at least one scene together. 

* For substitute, using **karate** club network data from **igraphdata** pkg.

```{r}
## get list of datasets in igraphdata
#data(package='igraphdata')
## import data set
data('karate', package='igraphdata')

## get description of UKfaculty
karate

```

From this we can tell:

* Undirected graph (U in UNW)
* Named graph: has 'name' attribute for vertices (N in UNW)
* Weighted graph (W in UNW)
* not Bipartite (don't know what this is, not sure it comes up often)
* 34 vertices
* 78 edges
* attributes: 
    + graph: name (character), Citation (character), Author (character) 
    + vertices: Faction (number), name (character), label (character), color (number)
    + edges: weight (edges/number)

[Some explanation in official documentation here](https://igraph.org/r/doc/aaa-igraph-package.html)

To align with Forrest Gump data in Datacamp exercises we need to:

1. convert edges into data frame
2. drop the weighting to make it unweighted
3. rename cols to 'V1', 'V2'

```{r}
gdf <- igraph::as_data_frame(karate, what='edges')
gdf <- gdf %>% select(-weight) %>% rename(
  V1=from,
  V2=to
)
```

### Prep Data

Following along with exercises, convert data frame to graph

```{r}
g <- graph_from_data_frame(gdf, directed=FALSE)
```

### Eigen Centrality

Eigen centrality is a measure of 'connectedness' within the network. Individuals with high eigenvector centrality are those that are highly connected to other highly connected individuals. 

Calculate eigen centrality and identify vertex with highest:

```{r}
g.ec <- eigen_centrality(g)
which.max(g.ec$vector)
```

#### Plot

Plot the network, using eigen centrality to set the size of vertices in the plot.

```{r}
plot(g,
     vertex.label.color="blue",
     vertex.label.cex=0.8,
     vertex.size=30*(g.ec$vector),
     edge.color='gray88',
     main='Karate Club Network')
```

### Density, Ave Length, Diameter

Calculate density, diameter, ave length: 

```{r}
gden <- edge_density(g)
gdia <- diameter(g, directed = FALSE)
gad <- mean_distance(g, directed = FALSE)

cat('Density: ',gdia,'\n','Diameter: ',gdia,'\n','Avg Dist.: ',gad)
```

### Random Graphs for Context

Numbers above don't have much meaning without context. In order to provide some context, 
**random graphs** are generated by algorithm to match characteristics of a given graph. The stats for the random graphs can be used to compare against particular graph.

Generate single random graph

```{r}
g.random <- erdos.renyi.game(n=gorder(g), p.or.m = gden, type='gnp')

plot(g.random)
edge_density(g.random)
mean_distance(g.random, directed = FALSE)
```

Generate multiple random graphs for comparison

```{r}
## generate 1000 graphs
gnum <- 1000
gl <- vector('list',gnum)

for(i in 1:gnum){
  gl[[i]] <- erdos.renyi.game(n=gorder(g),
                              p.or.m=gden,
                              type='gnp')
}

gl.apls <- unlist(lapply(gl, mean_distance, directed=FALSE))

hist(gl.apls)
abline(v=gad, col='red', lty=3, lwd=2)

## calc % of time avg distance from random generated ## graphs is lower than original graph

mean(gl.apls < gad)
```

### Network Substructures

Methods for describing network sub-structure.

#### Triangles and transivity

How many closed triangles, as proportion of all possible triangles within graph?

#### Cliques

* Every vertex connected to every other vertex
* Rare situation
* More common some vertices connected together within larger network (for these, all triangles are closed)

```{r}
## TRANSITIVITY
## all triangles in network
matrix(triangles(g), nrow=3)
## count of triangles with 'Actor 3' in vertex
count_triangles(g, vids='Actor 3')
## global transitivity
g.tr <- transitivity(g)
g.tr
# local transitivity for 'Actor 3'
transitivity(g, vids='Actor 3', type='local')
```

Back to randomizations to analyze transivity: 

* is transitivity for our network higher/lower than what we would expect by chance for networks with similar size and density? 

```{r}
## transitivity comparisons via randomization
gl.tr <- lapply(gl, transitivity)
gl.trs <- unlist(gl.tr)
summary(gl.trs)
mean(gl.trs > gl.tr)
```

```{r}
## CLIQUES
largest_cliques(g)
## identify maximal cliques
clq <- max_cliques(g)
## calc size of max clique
table(unlist(lapply(clq, length)))
```

#### Visualize largest cliques

```{r}
lc <- largest_cliques(g)
gs1 <- as.undirected(subgraph(g, lc[[1]]))
gs2 <- as.undirected(subgraph(g, lc[[2]]))
## show plots side by side
par(mfrow=c(1,2))

plot(gs1,
     vertex.label.color='black',
     vertex.label.cex=0.9,
     vertex.size=0,
     main='Largest Clique 1',
     layout=layout.circle(gs1))

plot(gs2,
     vertex.label.color='black',
     vertex.label.cex=0.9,
     vertex.size=0,
     main='Largest Clique 1',
     layout=layout.circle(gs1))
```

